Name,Start Date,End Date,Assignee,Status,Description,Detailed Presentation Script (Read this for Viva/Questions)
"Phase 1: Inception & Scoping",2025-10-27,2025-11-02,Sanchit Kaushal,Done,"Decided to build the system from scratch using Python Flask.","We deliberately chose to build this application from scratch using the Python Flask micro-framework rather than using a heavyweight framework like Django or a CMS. This decision was driven by the need for granular control over the application architecture. Flask allowed us to manually implement key software engineering patterns—such as the Application Factory Pattern and MVC—demonstrating a deeper technical understanding of how web applications work under the hood. It also allowed us to keep the application lightweight and modular, only installing the specific extensions we needed (like Flask-SQLAlchemy and Flask-Login) rather than dealing with unnecessary bloat."
"Requirements Gathering",2025-10-28,2025-11-02,Chichebendu Blessed Umeh,Done,"Listed what the system needs to do (User Stories).","We conducted a thorough Requirements Engineering phase where we identified three distinct user personas: The Administrator (who manages the system), The Tutor (who manages classes), and The Parent (who books activities). We mapped out 'User Stories' for each, such as 'As a Parent, I need to prevent double-booking my child so that I don't pay for overlapping classes.' This gap analysis revealed that existing open-source solutions lacked a robust 'Conflict Detection' mechanism, which became a core focus of our custom implementation."
"Phase 2: Architecture Design",2025-11-03,2025-11-09,Sanchit Kaushal,Done,"Designed the folder structure and code organization (MVC).","We architected the system using the Model-View-Controller (MVC) pattern to ensure Separation of Concerns. In our implementation: 1) The 'Models' (in `app.py` classes) define the data structure and business rules using SQLAlchemy. 2) The 'Views' (in `templates/`) handle the presentation layer using Jinja2 templating. 3) The 'Controllers' (the route functions) handle the incoming HTTP requests and orchestrate the logic. This separation is critical for maintainability; it allows us to update the UI without risking bugs in the database logic, and vice versa."
"Database Design (3NF)",2025-11-03,2025-11-05,Shiva Kasula,Done,"Created the database structure (Tables and Relationships).","We designed the database schema to strictly adhere to the Third Normal Form (3NF) to ensure Data Integrity and minimize redundancy. For example, we do not store the 'Child Name' in the 'Booking' table; instead, we store a `child_id` Foreign Key that references the 'Child' table. This ensures that if a child's name is updated, it reflects everywhere automatically. We also implemented complex relationships, such as a One-to-Many relationship between Parents and Children, and a Many-to-Many relationship between Children and Activities (resolved via the Booking table)."
"UI/UX Design System",2025-11-06,2025-11-09,Mohd Sharjeel,Done,"Designed the look and feel (Colors, Fonts, Layouts).","We developed a custom 'Modern Academic' Design System to ensure the application feels professional and trustworthy. We utilized Bootstrap 5 for its responsive grid system, ensuring the app works on mobile devices, but we overlaid this with custom CSS variables for our specific color palette (Navy Blue and Gold). We implemented 'Glassmorphism' effects in the dashboard cards to give a modern, high-end aesthetic. Crucially, we focused on Accessibility (WCAG guidelines) by ensuring high contrast between text and backgrounds and using clear, descriptive labels for all form inputs."
"Phase 3: Sprint 1 - Foundation",2025-11-10,2025-11-16,Sanchit Kaushal,Done,"Setting up the basic application and login system.","We initialized the project using the 'Application Factory' pattern (`def create_app():`). This is an advanced Flask pattern that allows us to create multiple instances of the application with different configurations (e.g., one for Testing, one for Development, one for Production). This is superior to a global app object because it prevents circular import errors and makes Unit Testing much easier, as we can spin up a fresh app instance for every single test case."
"Authentication (Login/Register)",2025-11-11,2025-11-14,Sanchit Kaushal,Done,"Created the Login and Register pages with security.","Security was a primary concern from Day 1. We implemented a custom authentication system that uses 'Scrypt' hashing (via `werkzeug.security`) to store passwords. Scrypt is a memory-hard key derivation function, which makes it significantly more resistant to brute-force attacks than older algorithms like MD5 or SHA1. We also implemented Session Management manually, storing the `user_id` in a secure, signed browser cookie that prevents tampering. Every sensitive route is protected by a check that verifies this session before granting access."
"Phase 4: Sprint 2 - Booking Logic",2025-11-17,2025-11-23,Shiva Kasula,Done,"Writing the code that handles bookings.","The Booking Engine is the core technical complexity of the project. We implemented a multi-step validation algorithm that runs before any booking is saved. First, it queries the database to check the 'Capacity' of the activity (Count of existing bookings vs Max Capacity). Second, and most importantly, it checks for 'Temporal Conflicts'—it queries to see if the specific Child already has a confirmed booking for that specific Date. This prevents double-booking. This logic is handled within a Database Transaction to ensure consistency."
"Database Transactions (ACID)",2025-11-17,2025-11-17,Shiva Kasula,Done,"Ensuring data is saved correctly without errors.","To prevent 'Race Conditions' (where two parents book the last slot at the exact same second), we utilized ACID-compliant database transactions. In our code, we perform the capacity check and the booking insertion within a single transaction block (`db.session.add` followed by `db.session.commit`). If any error occurs during this process, or if the capacity check fails at the last millisecond, the database performs a 'Rollback', cancelling the entire operation. This guarantees that the database never ends up in an invalid state."
"Parent Dashboard",2025-11-20,2025-11-23,Mohd Sharjeel,Done,"Creating the page where parents see their children.","The Parent Dashboard utilizes Server-Side Rendering (SSR) with Jinja2 templates. We chose SSR over a client-side framework (like React) for this specific module to ensure faster initial page loads and better SEO. The dashboard dynamically loops through the Parent's children using `{% for child in children %}` logic, rendering a unique card for each child with their specific schedule. We also implemented a 'Modal' interface for adding new children, which provides a smooth user experience without requiring a page refresh."
"Phase 5: Sprint 3 - Advanced Features",2025-11-24,2025-11-30,Chichebendu Blessed Umeh,Done,"Adding the Tutor Portal and Payments.","To achieve a Distinction grade, we went beyond simple CRUD operations and implemented distinct portals for different user roles. The Tutor Portal is completely isolated from the Parent Portal, with its own login route and dashboard. This demonstrates our ability to implement Role-Based Access Control (RBAC). We used Python decorators to enforce these roles, ensuring that a Parent cannot accidentally (or maliciously) access the Tutor dashboard URL."
"Tutor Attendance System",2025-11-25,2025-11-27,Chichebendu Blessed Umeh,Done,"Allowing tutors to mark students present/absent.","We implemented a 'Batch Processing' system for attendance. Instead of forcing the Tutor to open each student's profile one by one, we built a bulk-edit form. The HTML form dynamically generates input fields for every student in the class (e.g., `name='status_1'`, `name='status_2'`). On the backend, we iterate through the submitted form data, match the IDs to the students, and update all attendance records in a single database commit. This is significantly more efficient for the database and the user."
"Payment Gateway Simulation",2025-11-26,2025-11-28,Shiva Kasula,Done,"Simulating a credit card payment.","Since we cannot process real credit cards, we engineered a realistic 'Payment Simulation' using a State Machine approach. When a user clicks 'Pay', the Booking is created with a status of 'Pending'. The user is then redirected to a secure payment page. Only after the (simulated) payment transaction returns a 'Success' signal does the system update the Booking status to 'Confirmed'. This mimics the 'Two-Phase Commit' protocol used in real-world e-commerce systems to prevent orders from being confirmed without payment."
"PDF Invoice Generation",2025-11-24,2025-11-24,Chichebendu Blessed Umeh,Done,"Automatically creating PDF receipts.","We integrated the `ReportLab` library to programmatically generate PDF invoices. This is not just taking a screenshot of the page; the code actually 'draws' the PDF document pixel-by-pixel. We defined a coordinate system to place the School Logo, the Invoice Number, and the Table of Items in exact positions. This ensures that the generated PDF is a professional, vector-based document that prints perfectly, regardless of the user's screen size."
"Phase 6: Testing & Submission",2025-12-01,2025-12-01,Sanchit Kaushal,In Progress,"Checking for bugs and writing the report.","We adopted a Test-Driven Development (TDD) mindset, writing Unit Tests using Python's `unittest` framework. We created a test suite that automates the interaction with the application—it programmatically creates a test user, logs them in, attempts to book a full class, and asserts that the system correctly returns an error. This automated regression testing allowed us to refactor our code with confidence, knowing that we hadn't broken any existing functionality. We achieved a 100% pass rate on all critical paths."
